class CryptoUtil{constructor(){}static browser(){return null==this._browser&&(this._browser=require("detect-browser")),null==this._browser&&(this._browser={name:"unknown"}),this._browser}static crypto(){return window.crypto}static subtle(){let subtle=null;switch(CryptoUtil.browser().name){case"chrome":case"firefox":subtle=window.crypto.subtle;break;case"safari":subtle=window.crypto.webkitSubtle;break;default:subtle=null}return subtle}static jwkToBase64(jwk){let key=null;switch(CryptoUtil.browser().name){case"chrome":case"firefox":key=CryptoUtil.jsonToBase64(jwk);break;case"safari":key=CryptoUtil.arrayBufferToBase64(jwk);break;default:key=null}return key}static base64ToJwk(key){let jwk=null;switch(CryptoUtil.browser().name){case"chrome":case"firefox":jwk=CryptoUtil.base64ToJson(key);break;case"safari":jwk=CryptoUtil.base64ToArrayBuffer(key);break;default:jwk=null}return jwk}static arrayBufferToString(buffer){if(!buffer)return null;let string="";const bytes=new Uint8Array(buffer),len=bytes.byteLength;for(var i=0;i<len;i++)string+=String.fromCharCode(bytes[i]);return string}static arrayBufferToBase64(buffer){if(!buffer)return null;const binary=CryptoUtil.arrayBufferToString(buffer);return window.btoa(binary)}static stringToArrayBuffer(string){if(!string)return null;const len=string.length,bytes=new Uint8Array(len);for(var i=0;i<len;i++)bytes[i]=string.charCodeAt(i);return bytes.buffer}static base64ToArrayBuffer(base64){if(!base64)return null;const binaryString=window.atob(base64);return CryptoUtil.stringToArrayBuffer(binaryString)}static hexToBase64(hex){if(!hex)return null;const binaryString=CryptoUtil.hexToString(hex);return window.btoa(binaryString)}static base64ToHex(base64){if(!base64)return null;const binaryString=window.atob(base64);return CryptoUtil.stringToHex(binaryString)}static hexToBase64u(hex){if(!hex)return null;const base64=CryptoUtil.hexToBase64(hex);return CryptoUtil.base64ToBase64u(base64)}static hexToString(hex){let string="";for(let i=0;i<hex.length;i+=2)string+=String.fromCharCode(parseInt(hex.substr(i,2),16));return string}static stringToHex(string){let hex="";for(let i=0;i<string.length;i++)hex+=("0"+string.charCodeAt(i).toString(16)).slice(-2);return hex}static base64ToBase64u(base64){let string=base64.replace(/\+/g,"-");return(string=string.replace(/\//g,"_")).replace(/=/g,"")}static jsonToBase64(json){const str=JSON.stringify(json);return window.btoa(str)}static base64ToJson(base64){const str=window.atob(base64);return JSON.parse(str)}}class CryptoAESCBC{constructor(){}generateKeys(length=256){return this.length=length,this.iv=CryptoUtil.arrayBufferToBase64(CryptoUtil.crypto().getRandomValues(new Uint8Array(16))),CryptoUtil.subtle().generateKey({name:"AES-CBC",length:this.length},!0,["encrypt","decrypt"]).then(key=>{this.cryptoKey=key;return Promise.resolve(this)})}createKeyFromHex(hexKey,iv){const key=CryptoAESCBC._createKeyFromHex(hexKey);this.key=CryptoUtil.jsonToBase64(key),this.length=hexKey.length/2*8,this.iv=iv?CryptoUtil.hexToBase64(iv):CryptoUtil.arrayBufferToBase64(CryptoUtil.crypto().getRandomValues(new Uint8Array(16)));const keydata=CryptoUtil.base64ToJwk(this.key);return CryptoAESCBC._importKey(keydata,["encrypt","decrypt"]).then(pk=>{this.cryptoKey=pk;return Promise.resolve(this)})}exportKeys(){return this.cryptoKey&&!0===this.cryptoKey.extractable&&this.iv?CryptoUtil.subtle().exportKey("jwk",this.cryptoKey).then(keydata=>{this.key=CryptoUtil.jwkToBase64(keydata);return Promise.resolve(this)}):Promise.reject(new Error("there is no extractable key or IV"))}importKeys(key,iv){if(!key||!iv)return Promise.reject("empty key or initial vector are not allowed");this.key=key,this.iv=iv;const keydata=CryptoUtil.base64ToJwk(this.key);return CryptoAESCBC._importKey(keydata,["encrypt","decrypt"]).then(pk=>{this.cryptoKey=pk;return Promise.resolve(this)})}encrypt(textData){return CryptoUtil.subtle().encrypt({name:"AES-CBC",iv:CryptoUtil.base64ToArrayBuffer(this.iv)},this.cryptoKey,CryptoUtil.stringToArrayBuffer(textData)).then(encryptedBuffer=>Promise.resolve(CryptoUtil.arrayBufferToBase64(encryptedBuffer)))}decrypt(encryptedTextData){return CryptoUtil.subtle().decrypt({name:"AES-CBC",iv:CryptoUtil.base64ToArrayBuffer(this.iv)},this.cryptoKey,CryptoUtil.base64ToArrayBuffer(encryptedTextData)).then(decryptedBuffer=>Promise.resolve(CryptoUtil.arrayBufferToString(decryptedBuffer)))}static _createKeyFromHex(hexKey){return{kty:"oct",k:CryptoUtil.hexToBase64u(hexKey),alg:"A256CBC",ext:!0}}static _importKey(keydata,purposes){return keydata?CryptoUtil.subtle().importKey("jwk",keydata,{name:"AES-CBC"},!1,purposes):Promise.resolve(null)}}class CryptoAESGCM{constructor(){}static createKeyFromHex(hexKey){return{kty:"oct",k:CryptoUtil.hexToBase64u(hexKey),alg:"A256GCM",ext:!0}}generateKeys(length=256){return this.length=length,this.iv=CryptoUtil.arrayBufferToBase64(CryptoUtil.crypto().getRandomValues(new Uint8Array(12))),CryptoUtil.subtle().generateKey({name:"AES-GCM",length:this.length},!0,["encrypt","decrypt"]).then(key=>{this.cryptoKey=key;return Promise.resolve(this)})}createKeyFromHex(hexKey){const key=CryptoAESGCM.createKeyFromHex(hexKey);this.key=CryptoUtil.jsonToBase64(key),this.length=hexKey.length/2*8,this.iv=CryptoUtil.arrayBufferToBase64(CryptoUtil.crypto().getRandomValues(new Uint8Array(12)));const keydata=CryptoUtil.base64ToJwk(this.key);return CryptoAESGCM._importKey(keydata,["encrypt","decrypt"]).then(pk=>{this.cryptoKey=pk;return Promise.resolve(this)})}exportKeys(){return this.cryptoKey&&!0===this.cryptoKey.extractable&&this.iv?CryptoUtil.subtle().exportKey("jwk",this.cryptoKey).then(keydata=>{this.key=CryptoUtil.jwkToBase64(keydata);return Promise.resolve(this)}):Promise.reject(new Error("there is no extractable key or IV"))}importKeys(key,iv){if(!key||!iv)return Promise.reject("empty key or initial vector are not allowed");this.key=key,this.iv=iv;const keydata=CryptoUtil.base64ToJwk(this.key);return CryptoAESGCM._importKey(keydata,["encrypt","decrypt"]).then(pk=>{this.cryptoKey=pk;return Promise.resolve(this)})}encrypt(textData,note){return CryptoUtil.subtle().encrypt({name:"AES-GCM",iv:CryptoUtil.base64ToArrayBuffer(this.iv),additionalData:CryptoUtil.base64ToArrayBuffer(note),tagLength:128},this.cryptoKey,CryptoUtil.stringToArrayBuffer(textData)).then(encryptedBuffer=>Promise.resolve(CryptoUtil.arrayBufferToBase64(encryptedBuffer)))}decrypt(encryptedTextData,note){return CryptoUtil.subtle().decrypt({name:"AES-GCM",iv:CryptoUtil.base64ToArrayBuffer(this.iv),additionalData:CryptoUtil.base64ToArrayBuffer(note),tagLength:128},this.cryptoKey,CryptoUtil.base64ToArrayBuffer(encryptedTextData)).then(decryptedBuffer=>Promise.resolve(CryptoUtil.arrayBufferToString(decryptedBuffer)))}static _importKey(keydata,purposes){return keydata?CryptoUtil.subtle().importKey("jwk",keydata,{name:"AES-GCM"},!1,purposes):Promise.resolve(null)}}class CryptoRSA{constructor(){}generateKeys(modulusLength=2048){return this.modulusLength=modulusLength,CryptoUtil.subtle().generateKey({name:"RSA-OAEP",modulusLength:this.modulusLength,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},!0,["encrypt","decrypt"]).then(key=>{this.cryptoPublicKey=key.publicKey;this.cryptoPrivateKey=key.privateKey;return Promise.resolve(this)})}exportKeys(){return this.cryptoPrivateKey&&!0===this.cryptoPrivateKey.extractable&&this.cryptoPublicKey&&!0===this.cryptoPublicKey.extractable?CryptoUtil.subtle().exportKey("jwk",this.cryptoPrivateKey).then(keydata=>{this.privateKey=CryptoUtil.arrayBufferToBase64(keydata);return CryptoUtil.subtle().exportKey("jwk",this.cryptoPublicKey)}).then(keydata=>{this.publicKey=CryptoUtil.arrayBufferToBase64(keydata);return Promise.resolve(this)}):Promise.reject(new Error("there is no one of the keys of one of them is not extractable"))}importKeys(privateKey,publicKey){if(!privateKey&&!publicKey)return Promise.reject("both empty keys are not allowed");this.privateKey=privateKey,this.publicKey=publicKey;const privateKeydata=CryptoUtil.base64ToArrayBuffer(this.privateKey),publicKeydata=CryptoUtil.base64ToArrayBuffer(this.publicKey);return CryptoRSA._importKey(privateKeydata,"decrypt").then(pk=>{this.cryptoPrivateKey=pk;return CryptoRSA._importKey(publicKeydata,"encrypt")}).then(pk=>{this.cryptoPublicKey=pk;return Promise.resolve(this)})}encrypt(textData){return CryptoUtil.subtle().encrypt({name:"RSA-OAEP",hash:{name:"SHA-1"}},this.cryptoPublicKey,CryptoUtil.stringToArrayBuffer(textData)).then(encryptedBuffer=>Promise.resolve(CryptoUtil.arrayBufferToBase64(encryptedBuffer)))}decrypt(encryptedTextData){return CryptoUtil.subtle().decrypt({name:"RSA-OAEP",hash:{name:"SHA-1"}},this.cryptoPrivateKey,CryptoUtil.base64ToArrayBuffer(encryptedTextData)).then(decryptedBuffer=>Promise.resolve(CryptoUtil.arrayBufferToString(decryptedBuffer)))}static _importKey(keydata,purpose){return keydata?CryptoUtil.subtle().importKey("jwk",keydata,{name:"RSA-OAEP",hash:{name:"SHA-1"}},!1,[purpose]):Promise.resolve(null)}}class Crypto{constructor(rsaLength=2048,aesLength=256){this.rsa=new CryptoRSA,this.aes=new CryptoAES,this.rsaLength=rsaLength,this.aesLength=aesLength}generateKeys(){return this.rsa.generateKeys(this.rsaLength)}importKeys(privateKey,publicKey){return this.rsa.importKeys(privateKey,publicKey)}exportKeys(){return this.rsa.exportKeys()}encrypt(textData){let encryptedData=null,encryptedKey=null;const textData64=this._encode64(textData);return this.aes.generateKeys(this.aesLength).then(aes=>this.aes.exportKeys()).then(aes=>this.aes.encrypt(textData64)).then(encrypted=>{const key=this._composeKeyIV(this.aes.key,this.aes.iv);encryptedData=encrypted;return this.rsa.encrypt(key)}).then(encrypted=>{encryptedKey=encrypted;return Promise.resolve(this._composeEncryptedKeyData(encryptedKey,encryptedData))})}decrypt(encryptedTextData){const encryptedKey=this._extractEncryptedKey(encryptedTextData),encryptedData=this._extractEncryptedData(encryptedTextData);return this.rsa.decrypt(encryptedKey).then(decryptedKey=>{const aesIV=this._extractAESIV(decryptedKey);const aesKey=this._extractAESKey(decryptedKey);return this.aes.importKeys(aesKey,aesIV)}).then(aes=>this.aes.decrypt(encryptedData)).then(decrypted64=>{const decrypted=this._decode64(decrypted64);return Promise.resolve(decrypted)})}_encode64(text){return text}_decode64(text64){return text64}_extractEncryptedKey(keyData){const idx=keyData.indexOf(" ");return keyData.substring(0,idx)}_extractEncryptedData(keyData){const idx=keyData.indexOf(" ");return keyData.substring(idx+1)}_composeEncryptedKeyData(key,data){return`${key} ${data}`}_extractAESIV(key){const idx=key.indexOf(" ");return key.substring(0,idx)}_extractAESKey(key){const idx=key.indexOf(" ");return key.substring(idx+1)}_composeKeyIV(key,iv){return`${iv} ${key}`}}const cu=new CryptoUtil;exports.AESCBC=CryptoAESCBC,exports.AESGCM=CryptoAESGCM,exports.RSA=CryptoRSA,exports.Util=CryptoUtil;