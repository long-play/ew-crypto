class CryptoUtil{constructor(){}static crypto(){return window.crypto}static subtle(){return window.crypto.webkitSubtle}static arrayBufferToString(buffer){if(!buffer)return null;let string="";const bytes=new Uint8Array(buffer),len=bytes.byteLength;for(var i=0;i<len;i++)string+=String.fromCharCode(bytes[i]);return string}static arrayBufferToBase64(buffer){if(!buffer)return null;const binary=CryptoUtil.arrayBufferToString(buffer);return window.btoa(binary)}static stringToArrayBuffer(string){if(!string)return null;const len=string.length,bytes=new Uint8Array(len);for(var i=0;i<len;i++)bytes[i]=string.charCodeAt(i);return bytes.buffer}static base64ToArrayBuffer(base64){if(!base64)return null;const binaryString=window.atob(base64);return CryptoUtil.stringToArrayBuffer(binaryString)}}class CryptoAES{constructor(){}generateKeys(length=256){return this.length=length,this.iv=CryptoUtil.arrayBufferToBase64(CryptoUtil.crypto().getRandomValues(new Uint8Array(16))),CryptoUtil.subtle().generateKey({name:"AES-CBC",length:this.length},!0,["encrypt","decrypt"]).then(key=>{this.cryptoKey=key;return Promise.resolve(this)})}exportKeys(){return this.cryptoKey&&!0===this.cryptoKey.extractable&&this.iv?CryptoUtil.subtle().exportKey("jwk",this.cryptoKey).then(keydata=>{this.key=CryptoUtil.arrayBufferToBase64(keydata);return Promise.resolve(this)}):Promise.reject(new Error("there is no extractable key or IV"))}importKeys(key,iv){if(!key||!iv)return Promise.reject("empty key or initial vector are not allowed");this.key=key,this.iv=iv;const keydata=CryptoUtil.base64ToArrayBuffer(this.key);return CryptoUtil.importKey(keydata,["encrypt","decrypt"]).then(pk=>{this.cryptoKey=pk;return Promise.resolve(this)})}encrypt(textData){return CryptoUtil.subtle().encrypt({name:"AES-CBC",iv:CryptoUtil.base64ToArrayBuffer(this.iv)},this.cryptoKey,CryptoUtil.stringToArrayBuffer(textData)).then(encryptedBuffer=>Promise.resolve(CryptoUtil.arrayBufferToBase64(encryptedBuffer)))}decrypt(encryptedTextData){return CryptoUtil.subtle().decrypt({name:"AES-CBC",iv:CryptoUtil.base64ToArrayBuffer(this.iv)},this.cryptoKey,CryptoUtil.base64ToArrayBuffer(encryptedTextData)).then(decryptedBuffer=>Promise.resolve(CryptoUtil.arrayBufferToString(decryptedBuffer)))}static _importKey(keydata,purposes){return keydata?CryptoUtil.subtle().importKey("jwk",keydata,{name:"AES-CBC"},!1,purposes):Promise.resolve(null)}}class CryptoRSA{constructor(){}generateKeys(modulusLength=2048){return this.modulusLength=modulusLength,CryptoUtil.crypto().generateKey({name:"RSA-OAEP",modulusLength:this.modulusLength,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},!0,["encrypt","decrypt"]).then(key=>{this.cryptoPublicKey=key.publicKey;this.cryptoPrivateKey=key.privateKey;return Promise.resolve(this)})}exportKeys(){return this.cryptoPrivateKey&&!0===this.cryptoPrivateKey.extractable&&this.cryptoPublicKey&&!0===this.cryptoPublicKey.extractable?CryptoUtil.crypto().exportKey("jwk",this.cryptoPrivateKey).then(keydata=>{this.privateKey=CryptoUtil.arrayBufferToBase64(keydata);return CryptoUtil.crypto().exportKey("jwk",this.cryptoPublicKey)}).then(keydata=>{this.publicKey=CryptoUtil.arrayBufferToBase64(keydata);return Promise.resolve(this)}):Promise.reject(new Error("there is no one of the keys of one of them is not extractable"))}importKeys(privateKey,publicKey){if(!privateKey&&!publicKey)return Promise.reject("both empty keys are not allowed");this.privateKey=privateKey,this.publicKey=publicKey;const privateKeydata=CryptoUtil.base64ToArrayBuffer(this.privateKey),publicKeydata=CryptoUtil.base64ToArrayBuffer(this.publicKey);return _importKey(privateKeydata,"decrypt").then(pk=>{this.cryptoPrivateKey=pk;return _importKey(publicKeydata,"encrypt")}).then(pk=>{this.cryptoPublicKey=pk;return Promise.resolve(this)})}encrypt(textData){return CryptoUtil.crypto().encrypt({name:"RSA-OAEP",hash:{name:"SHA-1"}},this.cryptoPublicKey,CryptoUtil.stringToArrayBuffer(textData)).then(encryptedBuffer=>Promise.resolve(CryptoUtil.arrayBufferToBase64(encryptedBuffer)))}decrypt(encryptedTextData){return CryptoUtil.crypto().decrypt({name:"RSA-OAEP",hash:{name:"SHA-1"}},this.cryptoPrivateKey,CryptoUtil.base64ToArrayBuffer(encryptedTextData)).then(decryptedBuffer=>Promise.resolve(CryptoUtil.arrayBufferToString(decryptedBuffer)))}static _importKey(keydata,purpose){return keydata?CryptoUtil.crypto().importKey("jwk",keydata,{name:"RSA-OAEP",hash:{name:"SHA-1"}},!1,[purpose]):Promise.resolve(null)}}class Crypto{constructor(rsaLength=2048,aesLength=256){this.rsa=new CryptoRSA,this.aes=new CryptoAES,this.rsaLength=rsaLength,this.aesLength=aesLength}generateKeys(){return this.rsa.generateKeys(this.rsaLength)}importKeys(privateKey,publicKey){return this.rsa.importKeys(privateKey,publicKey)}encrypt(textData){let encryptedData=null,encryptedKey=null;const textData64=_encode64(textData);return this.aes.generateKeys(this.aesLength).then(aes=>this.aes.exportKeys()).then(aes=>this.aes.encrypt(textData64)).then(encrypted=>{const key=_composeKeyIV(this.aes.key,this.aes.iv);encryptedData=encrypted;return this.rsa.encrypt(key)}).then(encrypted=>{encryptedKey=encrypted;return Promise.resolve(_composeEncryptedKeyData(encryptedKey,encryptedData))})}decrypt(encryptedTextData){const encryptedKey=_extractEncryptedKey(encryptedTextData),encryptedData=_extractEncryptedData(encryptedTextData);return this.rsa.decrypt(encryptedKey).then(decryptedKey=>{const aesIV=_extractAESIV(decryptedKey);const aesKey=_extractAESKey(decryptedKey);return this.aes.importKeys(aesKey,aesIV)}).then(aes=>this.aes.decrypt(encryptedData)).then(decrypted64=>{const decrypted=_decode64(decrypted64);return Promise.resolve(decrypted)})}_encode64(text){return text}_decode64(text64){return text64}_extractEncryptedKey(keyData){return keyData.substring(0,32)}_extractEncryptedData(keyData){return keyData.substring(32)}_composeEncryptedKeyData(key,data){return key+data}_extractAESIV(key){return keyData.substring(0,32)}_extractAESKey(key){return keyData.substring(32)}_composeKeyIV(key,iv){return iv+key}}