class CryptoUtil{constructor(){this._crypto=window.crypto,this._subtle=this._crypto.subtle}get crypto(){return this._crypto}get subtle(){return this._subtle}bufferToHex(e){return CryptoUtil.bufferToHex(e)}hexToBuffer(e){return CryptoUtil.hexToBuffer(e)}static crypto(){return window.crypto}static subtle(){return window.crypto.subtle}static bufferToHex(e){return Array.prototype.map.call(new Uint8Array(e),e=>("00"+e.toString(16)).slice(-2)).join("")}static hexToBuffer(e){return new Uint8Array(CryptoUtil.trimHex(e).match(/.{1,2}/g).map(e=>parseInt(e,16)))}static trimHex(e){return"0x"==e.slice(0,2)&&(e=e.slice(2)),e}}class CryptoAESGCM{constructor(){this._util=new CryptoUtil}generateKey(e=256){return this._length=e,this._util.subtle.generateKey({name:"AES-GCM",length:this._length},!0,["encrypt","decrypt"]).then(e=>(this._cryptoKey=e,Promise.resolve(this)))}exportKey(){if(!this._cryptoKey||!0!==this._cryptoKey.extractable)return Promise.reject(new Error("there is no extractable key"));return this._util.subtle.exportKey("raw",this._cryptoKey).then(e=>Promise.resolve(e))}importKey(e){if(!e)return Promise.reject("empty key or initial vector are not allowed");if("string"==typeof e&&(e=CryptoUtil.hexToBuffer(e)),32!==e.length)return Promise.reject("key has the wrong length");return this._util.subtle.importKey("raw",e,{name:"AES-GCM"},!1,["encrypt","decrypt"]).then(e=>(this._cryptoKey=e,Promise.resolve(this)))}encrypt(e,t){if(!this._cryptoKey)return Promise.reject("Crypto key is not initialized");"string"==typeof e&&(e=CryptoUtil.hexToBuffer(e)),"string"==typeof t&&(t=CryptoUtil.hexToBuffer(t));const r=this._util.crypto.getRandomValues(new Uint8Array(12));return this._util.subtle.encrypt({name:"AES-GCM",iv:r,additionalData:t,tagLength:128},this._cryptoKey,e).then(e=>{const t={ciphertext:e,iv:r};return Promise.resolve(t)})}decrypt(e,t,r){if(!this._cryptoKey)return Promise.reject("Crypto key is not initialized");if("string"==typeof e&&(e=CryptoUtil.hexToBuffer(e)),"string"==typeof t&&(t=CryptoUtil.hexToBuffer(t)),12!==t.length)return Promise.reject("IV has the wrong length");return"string"==typeof r&&(r=CryptoUtil.hexToBuffer(r)),this._util.subtle.decrypt({name:"AES-GCM",iv:t,additionalData:r,tagLength:128},this._cryptoKey,e).then(e=>Promise.resolve(e))}}const BN=require("bn.js"),EC=require("elliptic").ec,createHash=require("create-hash"),ec=new EC("secp256k1"),ecparams=ec.curve;class WCrypto{constructor(){}encrypt(e,t,r,i){t=CryptoUtil.trimHex(t),r=CryptoUtil.trimHex(r);const s=this._privateKeyCreateFromHex(t),o=(this._getPublicKeyFromPrivate(t),this._getPublicKey(r)),n=this._derive(o,s),c=this._sha256(n);return this._aesEncrypt(e,c.toString("hex"),i)}decrypt(e,t,r,i,s){t=CryptoUtil.trimHex(t),r=CryptoUtil.trimHex(r);const o=this._privateKeyCreateFromHex(t),n=(this._getPublicKeyFromPrivate(t),this._getPublicKey(r)),c=this._derive(n,o),l=this._sha256(c);return this._aesDecrypt(e,l.toString("hex"),i,s)}_aesEncrypt(e,t,r){return(new CryptoAESGCM).importKey(t).then(t=>t.encrypt(e,r)).then(e=>(console.log("enc: "+JSON.stringify(e)),Promise.resolve(e)))}_aesDecrypt(e,t,r,i){return(new CryptoAESGCM).importKey(t).then(t=>t.decrypt(e,r,i)).then(e=>(console.log("decr: "+e),Promise.resolve(e)))}_getPublicKey(e){var t=this._publicKeyCreateFromHex(e);return this._publicKeyConvert(t,!1)}_getPublicKeyFromPrivate(e){var t=this._publicKeyCreateFromPrivate(e);return this._publicKeyConvert(t,!1)}_derive(e,t){return this._ecdh(e,t)}_sha256(e){return createHash("sha256").update(e).digest()}_sha512(e){return createHash("sha512").update(e).digest()}_privateKeyCreateFromHex(e){return Buffer.from(e,"hex")}_publicKeyCreateFromHex(e,t){return Buffer.from(ec.keyFromPublic(e,"hex").getPublic(t,!0))}_publicKeyCreateFromPrivate(e,t){return Buffer.from(ec.keyFromPrivate(e).getPublic(t,!0))}_publicKeyConvert(e,t){const r=this._loadPublicKey(e);if(null===r)throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);return Buffer.from(r.getPublic(t,!0))}_loadPublicKey(e){const t=e[0];switch(t){case 2:case 3:return 33!==e.length?null:this._loadCompressedPublicKey(t,e.slice(1,33));case 4:case 6:case 7:return 65!==e.length?null:this._loadUncompressedPublicKey(t,e.slice(1,33),e.slice(33,65));default:return null}}_loadCompressedPublicKey(e,t){let r=new BN(t);if(r.cmp(ecparams.p)>=0)return null;const i=(r=r.toRed(ecparams.red)).redSqr().redIMul(r).redIAdd(ecparams.b).redSqrt();return 3===e!==i.isOdd()&&(i=i.redNeg()),ec.keyPair({pub:{x:r,y:i}})}_loadUncompressedPublicKey(e,t,r){let i=new BN(t),s=new BN(r);if(i.cmp(ecparams.p)>=0||s.cmp(ecparams.p)>=0)return null;if(i=i.toRed(ecparams.red),s=s.toRed(ecparams.red),(6===e||7===e)&&s.isOdd()!==(7===e))return null;const o=i.redSqr().redIMul(i);return s.redSqr().redISub(o.redIAdd(ecparams.b)).isZero()?ec.keyPair({pub:{x:i,y:s}}):null}_ecdh(e,t){var r=this._ecdhUnsafe(e,t,!0);return this._sha256(r)}_ecdhUnsafe(e,t,r){var i=this._loadPublicKey(e),s=new BN(t);return Buffer.from(i.pub.mul(s).encode(!0,r))}}exports.Util=CryptoUtil,exports.AESGCM=CryptoAESGCM,exports.WCrypto=WCrypto;