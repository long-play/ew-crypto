const createHash=require("create-hash");class CryptoUtil{constructor(){this._crypto=window.crypto,this._subtle=this._crypto.subtle}get crypto(){return this._crypto}get subtle(){return this._subtle}bufferToHex(t){return CryptoUtil.bufferToHex(t)}hexToBuffer(t){return CryptoUtil.hexToBuffer(t)}static crypto(){return window.crypto}static subtle(){return window.crypto.subtle}static bufferToHex(t){return"0x"+Array.prototype.map.call(new Uint8Array(t),t=>("00"+t.toString(16)).slice(-2)).join("")}static hexToBuffer(t){return new Uint8Array(CryptoUtil.trimHex(t).match(/.{1,2}/g).map(t=>parseInt(t,16)))}static trimHex(t){return"0x"==t.slice(0,2)&&(t=t.slice(2)),t}static sha256(t){return createHash("sha256").update(t).digest()}}class CryptoAESGCM{constructor(){this._util=new CryptoUtil}generateKey(t=256){return this._length=t,this._util.subtle.generateKey({name:"AES-GCM",length:this._length},!0,["encrypt","decrypt"]).then(t=>(this._cryptoKey=t,Promise.resolve(this)))}exportKey(){if(!this._cryptoKey||!0!==this._cryptoKey.extractable)return Promise.reject(new Error("there is no extractable key"));return this._util.subtle.exportKey("raw",this._cryptoKey).then(t=>Promise.resolve(t))}importKey(t){if(!t)return Promise.reject("empty key or initial vector are not allowed");if("string"==typeof t&&(t=CryptoUtil.hexToBuffer(t)),32!==t.length)return Promise.reject("key has the wrong length");return this._util.subtle.importKey("raw",t,{name:"AES-GCM"},!1,["encrypt","decrypt"]).then(t=>(this._cryptoKey=t,Promise.resolve(this)))}encrypt(t,e,r=null){if(!this._cryptoKey)return Promise.reject("Crypto key is not initialized");if("string"==typeof t&&(t=CryptoUtil.hexToBuffer(t)),"string"==typeof e&&(e=CryptoUtil.hexToBuffer(e)),null===r&&(r=this._util.crypto.getRandomValues(new Uint8Array(12))),"string"==typeof r&&(r=CryptoUtil.hexToBuffer(r)),12!==r.length)return Promise.reject("IV has the wrong length");return this._util.subtle.encrypt({name:"AES-GCM",iv:r,additionalData:e,tagLength:128},this._cryptoKey,t).then(t=>{const e={ciphertext:t=new Uint8Array(t),iv:r};return Promise.resolve(e)})}decrypt(t,e,r){if(!this._cryptoKey)return Promise.reject("Crypto key is not initialized");if("string"==typeof t&&(t=CryptoUtil.hexToBuffer(t)),"string"==typeof e&&(e=CryptoUtil.hexToBuffer(e)),12!==e.length)return Promise.reject("IV has the wrong length");return"string"==typeof r&&(r=CryptoUtil.hexToBuffer(r)),this._util.subtle.decrypt({name:"AES-GCM",iv:e,additionalData:r,tagLength:128},this._cryptoKey,t).then(t=>(t=new Uint8Array(t),Promise.resolve(t)))}}const BN=require("bn.js"),EC=require("elliptic").ec,ec=new EC("secp256k1");class WCrypto{constructor(){}encrypt(t,e,r,i){e=CryptoUtil.trimHex(e),r=CryptoUtil.trimHex(r);const o=ec.keyFromPrivate(e,"hex"),n=ec.keyFromPublic(r,"hex"),s=o.derive(n.pub).toString("hex"),y=CryptoUtil.sha256(s),p=CryptoUtil.sha256(y).toString("hex").slice(-24);return this._aesEncrypt(t,y.toString("hex"),p,i)}decrypt(t,e,r,i,o=null){e=CryptoUtil.trimHex(e),r=CryptoUtil.trimHex(r);const n=ec.keyFromPrivate(e,"hex"),s=ec.keyFromPublic(r,"hex"),y=n.derive(s.pub).toString("hex"),p=CryptoUtil.sha256(y);return null===o&&(o=CryptoUtil.sha256(p).toString("hex").slice(-24)),this._aesDecrypt(t,p.toString("hex"),o,i)}_aesEncrypt(t,e,r,i){return(new CryptoAESGCM).importKey(e).then(e=>e.encrypt(t,i,r)).then(t=>Promise.resolve(t))}_aesDecrypt(t,e,r,i){return(new CryptoAESGCM).importKey(e).then(e=>e.decrypt(t,r,i)).then(t=>Promise.resolve(t))}}exports.Util=CryptoUtil,exports.AESGCM=CryptoAESGCM,exports.WCrypto=WCrypto;