class CryptoUtil{constructor(){this._crypto=window.crypto,this._subtle=this._crypto.subtle}get crypto(){return this._crypto}get subtle(){return this._subtle}bufferToHex(e){return CryptoUtil.bufferToHex(e)}hexToBuffer(e){return CryptoUtil.hexToBuffer(e)}static crypto(){return window.crypto}static subtle(){return window.crypto.subtle}static bufferToHex(e){return Array.prototype.map.call(new Uint8Array(e),e=>("00"+e.toString(16)).slice(-2)).join("")}static hexToBuffer(e){return new Uint8Array(e.match(/.{1,2}/g).map(e=>parseInt(e,16)))}}class CryptoAESGCM{constructor(){this._util=new CryptoUtil}generateKey(e=256){return this._length=e,this._util.subtle.generateKey({name:"AES-GCM",length:this._length},!0,["encrypt","decrypt"]).then(e=>(this._cryptoKey=e,Promise.resolve(this)))}exportKey(){if(!this._cryptoKey||!0!==this._cryptoKey.extractable)return Promise.reject(new Error("there is no extractable key or IV"));return this._util.subtle.exportKey("raw",this._cryptoKey).then(e=>Promise.resolve(e))}importKey(e){if(!e)return Promise.reject("empty key or initial vector are not allowed");const r=e;return this._util.subtle.importKey("raw",r,{name:"AES-GCM"},!1,["encrypt","decrypt"]).then(e=>(this._cryptoKey=e,Promise.resolve(this)))}encrypt(e,r){const t=this._util.crypto.getRandomValues(new Uint8Array(12));return this._util.subtle.encrypt({name:"AES-GCM",iv:t,additionalData:r,tagLength:128},this._cryptoKey,e).then(e=>{const r={ciphertext:e,iv:t};return console.log(this._util.bufferToHex(e)),Promise.resolve(r)})}decrypt(e,r,t){return this._util.subtle.decrypt({name:"AES-GCM",iv:r,additionalData:t,tagLength:128},this._cryptoKey,e).then(e=>Promise.resolve(e))}}const BN=require("bn.js"),EC=require("elliptic").ec,createHash=require("create-hash"),ec=new EC("secp256k1"),ecparams=ec.curve;class WCrypto{constructor(){}encrypt(e,r,t,i){"0x"===r.slice(0,2)&&(r=r.slice(2)),"0x"===t.slice(0,2)&&(t=t.slice(2));const s=this._privateKeyCreateFromHex(r),c=(this._getPublicKeyFromPrivate(r),this._getPublicKey(t)),o=this._derive(c,s),n=this._sha256(o);return this._aesEncrypt(e,n.toString("hex"),i)}decrypt(e,r,t,i,s){"0x"===r.slice(0,2)&&(r=r.slice(2)),"0x"===t.slice(0,2)&&(t=t.slice(2));const c=this._privateKeyCreateFromHex(r),o=(this._getPublicKeyFromPrivate(r),this._getPublicKey(t)),n=this._derive(o,c),l=this._sha256(n);return this._aesDecrypt(e,l.toString("hex"),i,s)}_aesEncrypt(e,r,t){return(new CryptoAESGCM).importKey(r).then(r=>r.encrypt(e,t)).then(e=>(console.log("enc: "+JSON.stringify(e)),Promise.resolve(e)))}_aesDecrypt(e,r,t,i){return(new CryptoAESGCM).importKey(r).then(r=>r.decrypt(e,t,i)).then(e=>(console.log("decr: "+e),Promise.resolve(e)))}_getPublicKey(e){var r=this._publicKeyCreateFromHex(e);return this._publicKeyConvert(r,!1)}_getPublicKeyFromPrivate(e){var r=this._publicKeyCreateFromPrivate(e);return this._publicKeyConvert(r,!1)}_derive(e,r){return this._ecdh(e,r)}_sha256(e){return createHash("sha256").update(e).digest()}_sha512(e){return createHash("sha512").update(e).digest()}_privateKeyCreateFromHex(e){return Buffer.from(e,"hex")}_publicKeyCreateFromHex(e,r){return Buffer.from(ec.keyFromPublic(e,"hex").getPublic(r,!0))}_publicKeyCreateFromPrivate(e,r){return Buffer.from(ec.keyFromPrivate(e).getPublic(r,!0))}_publicKeyConvert(e,r){const t=this._loadPublicKey(e);if(null===t)throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);return Buffer.from(t.getPublic(r,!0))}_loadPublicKey(e){const r=e[0];switch(r){case 2:case 3:return 33!==e.length?null:this._loadCompressedPublicKey(r,e.slice(1,33));case 4:case 6:case 7:return 65!==e.length?null:this._loadUncompressedPublicKey(r,e.slice(1,33),e.slice(33,65));default:return null}}_loadCompressedPublicKey(e,r){let t=new BN(r);if(t.cmp(ecparams.p)>=0)return null;const i=(t=t.toRed(ecparams.red)).redSqr().redIMul(t).redIAdd(ecparams.b).redSqrt();return 3===e!==i.isOdd()&&(i=i.redNeg()),ec.keyPair({pub:{x:t,y:i}})}_loadUncompressedPublicKey(e,r,t){let i=new BN(r),s=new BN(t);if(i.cmp(ecparams.p)>=0||s.cmp(ecparams.p)>=0)return null;if(i=i.toRed(ecparams.red),s=s.toRed(ecparams.red),(6===e||7===e)&&s.isOdd()!==(7===e))return null;const c=i.redSqr().redIMul(i);return s.redSqr().redISub(c.redIAdd(ecparams.b)).isZero()?ec.keyPair({pub:{x:i,y:s}}):null}_ecdh(e,r){var t=this._ecdhUnsafe(e,r,!0);return this._sha256(t)}_ecdhUnsafe(e,r,t){var i=this._loadPublicKey(e),s=new BN(r);return Buffer.from(i.pub.mul(s).encode(!0,t))}}exports.Util=CryptoUtil,exports.AESGCM=CryptoAESGCM,exports.WCrypto=WCrypto;